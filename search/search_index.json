{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 2. Theoretical Foundation To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion. 2.1. Equations of Motion Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight. 2.2. Time of Flight The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 2.3. Range Equation The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\) 2.4. Maximum Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\) 3. Analysis of the Range 3.1. Dependence on Angle The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range. 3.2. Effect of Initial Velocity Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) . 3.3. Effect of Gravity A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it. \ud83d\udccc Improved Range Plot with Annotations import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show() 4. Implementation: Python Visualization We implement a computational tool to visualize the range as a function of the angle. \ud83d\ude80 Projectile Motion Simulation This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion. \ud83d\udccc How It Works? The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion. \ud83d\udda5 Use Cases \u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text 5. Air Resistance & Improved Models In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\) \ud83d\udccc Visualization with Air Resistance import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing) 1\ufe0f\u20e3 What Does This Code Do? This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video()) Link To The Simulation Above On Google Colab https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing 7. Conclusion The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations. 8. References & Further Reading Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion.","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight.","title":"2.1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-time-of-flight","text":"The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"2.2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-range-equation","text":"The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\)","title":"2.3. Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-maximum-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\)","title":"2.4. Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-angle","text":"The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range.","title":"3.1. Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-initial-velocity","text":"Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) .","title":"3.2. Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-effect-of-gravity","text":"A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it.","title":"3.3. Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#improved-range-plot-with-annotations","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udccc Improved Range Plot with Annotations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-visualization","text":"We implement a computational tool to visualize the range as a function of the angle.","title":"4. Implementation: Python Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation","text":"This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion.","title":"\ud83d\ude80 Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-it-works","text":"The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion.","title":"\ud83d\udccc How It Works?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#use-cases","text":"\u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text","title":"\ud83d\udda5 Use Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-air-resistance-improved-models","text":"In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\)","title":"5. Air Resistance &amp; Improved Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualization-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing)","title":"\ud83d\udccc Visualization with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-what-does-this-code-do","text":"This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video())","title":"1\ufe0f\u20e3 What Does This Code Do?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#link-to-the-simulation-above-on-google-colab","text":"https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing","title":"Link To The Simulation Above On Google Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion","text":"The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-references-further-reading","text":"Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"8. References &amp; Further Reading"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Motivation The forced damped pendulum is a classic example of a nonlinear system exhibiting a rich spectrum of dynamic behaviors. By introducing damping and external periodic forcing, the system transitions from simple harmonic motion to more complex phenomena, such as resonance, quasiperiodicity, and chaos. Understanding these dynamics is essential in fields ranging from mechanical engineering to climate modeling and electrical circuits. The introduction of an external periodic force adds new parameters, including amplitude and frequency, which significantly affect the pendulum's motion. By varying these parameters, we can observe different behaviors, including synchronized oscillations, chaotic motion, and resonance effects. These dynamics not only illustrate fundamental physical principles but also provide practical insights into engineering applications such as energy harvesting, vibration isolation, and resonance mitigation. 2. Theoretical Foundation 2.1 Governing Differential Equation The motion of a forced damped pendulum is governed by Newton\u2019s Second Law applied to rotational motion: \\[I \\alpha = \\sum \\tau\\] For a simple pendulum of mass \\(m\\) and length \\(L\\) , the moment of inertia about the pivot is: \\[I = mL^2\\] The forces acting on the pendulum bob include: Gravitational force : Produces a restoring torque: \\[\\tau_{\\text{gravity}} = -mgL \\sin \\theta\\] Damping force : Opposes motion due to air resistance: \\[\\tau_{\\text{damping}} = -b L \\frac{d\\theta}{dt}\\] External forcing : A periodic force applied to the system: \\[\\tau_{\\text{forcing}} = F_0 L \\cos(\\omega t)\\] Applying Newton\u2019s Second Law: \\[mL^2 \\frac{d^2\\theta}{dt^2} = -mgL \\sin\\theta - b L \\frac{d\\theta}{dt} + F_0 L \\cos(\\omega t)\\] Dividing by \\(mL^2\\) , we obtain the standard form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: Natural frequency : \\[\\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damping coefficient : \\[\\gamma = \\frac{b}{mL}\\] Forcing term : \\[A = \\frac{F_0}{mL}\\] 1.2 Approximate Solutions for Small-Angle Oscillations For small angles \\(\\theta \\ll 1\\) , we use the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the equation simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This is a linear inhomogeneous second-order differential equation that can be solved using standard techniques. 1.2.1 General Solution The general solution consists of: Homogeneous solution $ A = 0 $, solving: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0\\] The characteristic equation is: \\[r^2 + br + \\frac{g}{L} = 0\\] Solving for \\(r\\) , the solution depends on the damping coefficient \\(b\\) : Underdamped case \\(b^2 < 4g/L\\) : \\[\\theta_h(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t))\\] where \\( \\(\\omega{\\prime} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\) \\) is the damped frequency. Overdamped and critically damped cases are handled similarly but result in non-oscillatory motion. Particular solution for the forced term: \\[\\theta_p(t) = A_0 \\cos(\\omega t - \\delta)\\] where: \\[A_0 = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}}\\] and \\[\\tan\\delta = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Thus, the full solution is: \\[\\theta(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t)) + A_0 \\cos(\\omega t - \\delta)\\] where the first term decays over time, leaving only the steady-state oscillation. 1.3 Resonance Conditions and Energy Implications Resonance occurs when the driving frequency \\(\\omega\\) approaches the system\u2019s natural frequency: \\[\\omega \\approx \\sqrt{\\frac{g}{L}}\\] At resonance, the amplitude \\(A_0\\) is maximized: \\[A_{\\text{max}} \\approx \\frac{A}{b\\omega}\\] which shows that: - For small damping \\(b \\to 0\\) , the amplitude can grow excessively, leading to large oscillations. - For strong damping, resonance is suppressed, and energy is dissipated before large oscillations develop. The total energy of the system: $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} mgL \\theta^2 $ is maximized at resonance, which can lead to destructive consequences in mechanical systems (e.g., bridges, buildings). Damping helps dissipate this energy and stabilize the system. 2.2 Python Visualizations import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.1 # damping coefficient (s^-1) A = 0.5 # forcing amplitude omega = np.sqrt(g / L) # driving frequency (resonance condition, rad/s) theta0 = 0.1 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) # Time settings t_max = 20.0 # total simulation time (s) dt = 0.01 # time step (s) t = np.arange(0, t_max, dt) # time array # Define the system of ODEs def pendulum_derivatives(t, state, b, g, L, A, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * theta + A * np.cos(omega * t) return np.array([dtheta_dt, dtheta_dot_dt]) # RK4 solver def rk4_step(t, state, dt, b, g, L, A, omega): k1 = pendulum_derivatives(t, state, b, g, L, A, omega) k2 = pendulum_derivatives(t + dt/2, state + dt * k1/2, b, g, L, A, omega) k3 = pendulum_derivatives(t + dt/2, state + dt * k2/2, b, g, L, A, omega) k4 = pendulum_derivatives(t + dt, state + dt * k3, b, g, L, A, omega) return state + (dt / 6) * (k1 + 2*k2 + 2*k3 + k4) # Initialize arrays state = np.array([theta0, theta_dot0]) # [theta, theta_dot] theta = np.zeros(len(t)) theta_dot = np.zeros(len(t)) theta[0], theta_dot[0] = state # Simulate the motion for i in range(1, len(t)): state = rk4_step(t[i-1], state, dt, b, g, L, A, omega) theta[i], theta_dot[i] = state # Calculate total energy m = 1.0 # mass (kg), assumed for simplicity energy = 0.5 * m * L**2 * theta_dot**2 + 0.5 * m * g * L * theta**2 # Plotting plt.figure(figsize=(12, 8)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(t, theta, label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() # Energy vs Time plt.subplot(2, 1, 2) plt.plot(t, energy, label='Total Energy', color='orange') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.title('Total Energy Over Time') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: Phase space plot plt.figure(figsize=(6, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Space: Angle vs Angular Velocity') plt.grid(True) plt.legend() plt.show() Explanation of the Code Parameters The following physical constants and initial conditions are defined with realistic values: $ g $: Gravitational acceleration (m/s\u00b2). $ L $: Pendulum length (m). $ b $: Damping coefficient (s\u207b\u00b9). $ A $: Forcing amplitude. $ \\omega $: Driving frequency (rad/s), set to $ \\omega = \\sqrt{\\frac{g}{L}} $ to match the natural frequency for resonance. Initial conditions: $ \\theta_0 $: Initial angle (radians), starting the pendulum slightly displaced. $ \\dot{\\theta}_0 $: Initial angular velocity (rad/s). ODE Definition The pendulum_derivatives function computes the derivatives of the system: - $ \\frac{d\\theta}{dt} $: Angular velocity. - $ \\frac{d\\dot{\\theta}}{dt} $: Angular acceleration, based on the equation of motion. RK4 Solver The rk4_step function implements the 4th-order Runge-Kutta method to advance the solution one time step: - Numerically integrates the ODEs using four stages (k1, k2, k3, k4) to update $ \\theta $ and $ \\dot{\\theta} $. Simulation The simulation process: - A loop iterates over time, updating: - $ \\theta $: Angular displacement. - $ \\dot{\\theta} $: Angular velocity. - Energy is calculated using: - $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} m g L \\theta^2 $ (small-angle potential energy, in joules). Visualization The results are visualized with: - Two plots: 1. Angle ($ \\theta \\() vs. time. 2. Energy (\\) E $) vs. time. - A phase space plot: - $ \\theta $ vs. $ \\dot{\\theta} $, showing the system\u2019s trajectory in phase space. 3. Analysis of Dynamics 3.1 Influence of Parameters Damping coefficient \\((\\gamma)\\) : High damping suppresses oscillations. Low damping allows oscillations to persist longer. Driving force amplitude \\(( A )\\) : Larger $ A $ can lead to chaotic motion. Driving frequency \\(( \\omega )\\) : At \\(\\omega \\approx \\omega_0\\) , resonance occurs. For high \\(\\omega\\) , behavior becomes irregular. 3.2 Transition to Chaos As forcing increases, the system moves from periodic motion to quasiperiodic and eventually chaotic behavior. This is analyzed using: - Phase portraits (visualizing velocity vs. displacement) - Poincar\u00e9 sections (snapshots at regular time intervals) - Bifurcation diagrams (tracking equilibrium solutions as parameters vary) 4. Practical Applications Energy Harvesting : Piezoelectric pendulums convert oscillations into electrical energy. Suspension Bridges : Understanding resonance prevents structural failures. Electrical Circuits : Analogous to forced RLC circuits. Biomechanics : Gait patterns modeled using pendulum dynamics. 5. Computational Implementation 5.1 Numerical Simulation The forced damped pendulum equation is solved using numerical integration (Runge-Kutta method). The code generates: - Motion plots for varying parameters. - Phase portraits to visualize periodic and chaotic behavior. - Poincar\u00e9 sections for transition analysis. - Bifurcation diagrams to study nonlinear effects. 5.2 Model Limitations & Extensions Limitations : Small-angle approximations break down at large amplitudes. Linear damping does not always accurately model real-world resistance. External forcing is not always purely periodic. Extensions : Nonlinear damping (e.g., quadratic drag) can be incorporated. Stochastic forcing to simulate real-world perturbations. Coupled oscillators for multi-degree-of-freedom systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-motivation","text":"The forced damped pendulum is a classic example of a nonlinear system exhibiting a rich spectrum of dynamic behaviors. By introducing damping and external periodic forcing, the system transitions from simple harmonic motion to more complex phenomena, such as resonance, quasiperiodicity, and chaos. Understanding these dynamics is essential in fields ranging from mechanical engineering to climate modeling and electrical circuits. The introduction of an external periodic force adds new parameters, including amplitude and frequency, which significantly affect the pendulum's motion. By varying these parameters, we can observe different behaviors, including synchronized oscillations, chaotic motion, and resonance effects. These dynamics not only illustrate fundamental physical principles but also provide practical insights into engineering applications such as energy harvesting, vibration isolation, and resonance mitigation.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-governing-differential-equation","text":"The motion of a forced damped pendulum is governed by Newton\u2019s Second Law applied to rotational motion: \\[I \\alpha = \\sum \\tau\\] For a simple pendulum of mass \\(m\\) and length \\(L\\) , the moment of inertia about the pivot is: \\[I = mL^2\\] The forces acting on the pendulum bob include: Gravitational force : Produces a restoring torque: \\[\\tau_{\\text{gravity}} = -mgL \\sin \\theta\\] Damping force : Opposes motion due to air resistance: \\[\\tau_{\\text{damping}} = -b L \\frac{d\\theta}{dt}\\] External forcing : A periodic force applied to the system: \\[\\tau_{\\text{forcing}} = F_0 L \\cos(\\omega t)\\] Applying Newton\u2019s Second Law: \\[mL^2 \\frac{d^2\\theta}{dt^2} = -mgL \\sin\\theta - b L \\frac{d\\theta}{dt} + F_0 L \\cos(\\omega t)\\] Dividing by \\(mL^2\\) , we obtain the standard form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: Natural frequency : \\[\\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damping coefficient : \\[\\gamma = \\frac{b}{mL}\\] Forcing term : \\[A = \\frac{F_0}{mL}\\]","title":"2.1 Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-approximate-solutions-for-small-angle-oscillations","text":"For small angles \\(\\theta \\ll 1\\) , we use the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the equation simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This is a linear inhomogeneous second-order differential equation that can be solved using standard techniques.","title":"1.2 Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#121-general-solution","text":"The general solution consists of: Homogeneous solution $ A = 0 $, solving: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0\\] The characteristic equation is: \\[r^2 + br + \\frac{g}{L} = 0\\] Solving for \\(r\\) , the solution depends on the damping coefficient \\(b\\) : Underdamped case \\(b^2 < 4g/L\\) : \\[\\theta_h(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t))\\] where \\( \\(\\omega{\\prime} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\) \\) is the damped frequency. Overdamped and critically damped cases are handled similarly but result in non-oscillatory motion. Particular solution for the forced term: \\[\\theta_p(t) = A_0 \\cos(\\omega t - \\delta)\\] where: \\[A_0 = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}}\\] and \\[\\tan\\delta = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Thus, the full solution is: \\[\\theta(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t)) + A_0 \\cos(\\omega t - \\delta)\\] where the first term decays over time, leaving only the steady-state oscillation.","title":"1.2.1 General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance-conditions-and-energy-implications","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the system\u2019s natural frequency: \\[\\omega \\approx \\sqrt{\\frac{g}{L}}\\] At resonance, the amplitude \\(A_0\\) is maximized: \\[A_{\\text{max}} \\approx \\frac{A}{b\\omega}\\] which shows that: - For small damping \\(b \\to 0\\) , the amplitude can grow excessively, leading to large oscillations. - For strong damping, resonance is suppressed, and energy is dissipated before large oscillations develop. The total energy of the system: $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} mgL \\theta^2 $ is maximized at resonance, which can lead to destructive consequences in mechanical systems (e.g., bridges, buildings). Damping helps dissipate this energy and stabilize the system.","title":"1.3 Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-python-visualizations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.1 # damping coefficient (s^-1) A = 0.5 # forcing amplitude omega = np.sqrt(g / L) # driving frequency (resonance condition, rad/s) theta0 = 0.1 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) # Time settings t_max = 20.0 # total simulation time (s) dt = 0.01 # time step (s) t = np.arange(0, t_max, dt) # time array # Define the system of ODEs def pendulum_derivatives(t, state, b, g, L, A, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * theta + A * np.cos(omega * t) return np.array([dtheta_dt, dtheta_dot_dt]) # RK4 solver def rk4_step(t, state, dt, b, g, L, A, omega): k1 = pendulum_derivatives(t, state, b, g, L, A, omega) k2 = pendulum_derivatives(t + dt/2, state + dt * k1/2, b, g, L, A, omega) k3 = pendulum_derivatives(t + dt/2, state + dt * k2/2, b, g, L, A, omega) k4 = pendulum_derivatives(t + dt, state + dt * k3, b, g, L, A, omega) return state + (dt / 6) * (k1 + 2*k2 + 2*k3 + k4) # Initialize arrays state = np.array([theta0, theta_dot0]) # [theta, theta_dot] theta = np.zeros(len(t)) theta_dot = np.zeros(len(t)) theta[0], theta_dot[0] = state # Simulate the motion for i in range(1, len(t)): state = rk4_step(t[i-1], state, dt, b, g, L, A, omega) theta[i], theta_dot[i] = state # Calculate total energy m = 1.0 # mass (kg), assumed for simplicity energy = 0.5 * m * L**2 * theta_dot**2 + 0.5 * m * g * L * theta**2 # Plotting plt.figure(figsize=(12, 8)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(t, theta, label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() # Energy vs Time plt.subplot(2, 1, 2) plt.plot(t, energy, label='Total Energy', color='orange') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.title('Total Energy Over Time') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: Phase space plot plt.figure(figsize=(6, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Space: Angle vs Angular Velocity') plt.grid(True) plt.legend() plt.show()","title":"2.2 Python Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation-of-the-code","text":"","title":"Explanation of the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"The following physical constants and initial conditions are defined with realistic values: $ g $: Gravitational acceleration (m/s\u00b2). $ L $: Pendulum length (m). $ b $: Damping coefficient (s\u207b\u00b9). $ A $: Forcing amplitude. $ \\omega $: Driving frequency (rad/s), set to $ \\omega = \\sqrt{\\frac{g}{L}} $ to match the natural frequency for resonance. Initial conditions: $ \\theta_0 $: Initial angle (radians), starting the pendulum slightly displaced. $ \\dot{\\theta}_0 $: Initial angular velocity (rad/s).","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#ode-definition","text":"The pendulum_derivatives function computes the derivatives of the system: - $ \\frac{d\\theta}{dt} $: Angular velocity. - $ \\frac{d\\dot{\\theta}}{dt} $: Angular acceleration, based on the equation of motion.","title":"ODE Definition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#rk4-solver","text":"The rk4_step function implements the 4th-order Runge-Kutta method to advance the solution one time step: - Numerically integrates the ODEs using four stages (k1, k2, k3, k4) to update $ \\theta $ and $ \\dot{\\theta} $.","title":"RK4 Solver"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation","text":"The simulation process: - A loop iterates over time, updating: - $ \\theta $: Angular displacement. - $ \\dot{\\theta} $: Angular velocity. - Energy is calculated using: - $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} m g L \\theta^2 $ (small-angle potential energy, in joules).","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"The results are visualized with: - Two plots: 1. Angle ($ \\theta \\() vs. time. 2. Energy (\\) E $) vs. time. - A phase space plot: - $ \\theta $ vs. $ \\dot{\\theta} $, showing the system\u2019s trajectory in phase space.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-dynamics","text":"","title":"3. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-influence-of-parameters","text":"Damping coefficient \\((\\gamma)\\) : High damping suppresses oscillations. Low damping allows oscillations to persist longer. Driving force amplitude \\(( A )\\) : Larger $ A $ can lead to chaotic motion. Driving frequency \\(( \\omega )\\) : At \\(\\omega \\approx \\omega_0\\) , resonance occurs. For high \\(\\omega\\) , behavior becomes irregular.","title":"3.1 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-transition-to-chaos","text":"As forcing increases, the system moves from periodic motion to quasiperiodic and eventually chaotic behavior. This is analyzed using: - Phase portraits (visualizing velocity vs. displacement) - Poincar\u00e9 sections (snapshots at regular time intervals) - Bifurcation diagrams (tracking equilibrium solutions as parameters vary)","title":"3.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-practical-applications","text":"Energy Harvesting : Piezoelectric pendulums convert oscillations into electrical energy. Suspension Bridges : Understanding resonance prevents structural failures. Electrical Circuits : Analogous to forced RLC circuits. Biomechanics : Gait patterns modeled using pendulum dynamics.","title":"4. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-computational-implementation","text":"","title":"5. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-numerical-simulation","text":"The forced damped pendulum equation is solved using numerical integration (Runge-Kutta method). The code generates: - Motion plots for varying parameters. - Phase portraits to visualize periodic and chaotic behavior. - Poincar\u00e9 sections for transition analysis. - Bifurcation diagrams to study nonlinear effects.","title":"5.1 Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-model-limitations-extensions","text":"","title":"5.2 Model Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Small-angle approximations break down at large amplitudes. Linear damping does not always accurately model real-world resistance. External forcing is not always purely periodic.","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Nonlinear damping (e.g., quadratic drag) can be incorporated. Stochastic forcing to simulate real-world perturbations. Coupled oscillators for multi-degree-of-freedom systems.","title":"Extensions:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}