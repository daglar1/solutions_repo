{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 2. Theoretical Foundation To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion. 2.1. Equations of Motion Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight. 2.2. Time of Flight The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 2.3. Range Equation The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\) 2.4. Maximum Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\) 3. Analysis of the Range 3.1. Dependence on Angle The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range. 3.2. Effect of Initial Velocity Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) . 3.3. Effect of Gravity A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it. \ud83d\udccc Improved Range Plot with Annotations import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show() 4. Implementation: Python Visualization We implement a computational tool to visualize the range as a function of the angle. \ud83d\ude80 Projectile Motion Simulation This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion. \ud83d\udccc How It Works? The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion. \ud83d\udda5 Use Cases \u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text 5. Air Resistance & Improved Models In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\) \ud83d\udccc Visualization with Air Resistance import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing) 1\ufe0f\u20e3 What Does This Code Do? This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video()) Link To The Simulation Above On Google Colab https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing 7. Conclusion The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations. 8. References & Further Reading Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion.","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight.","title":"2.1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-time-of-flight","text":"The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"2.2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-range-equation","text":"The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\)","title":"2.3. Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-maximum-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\)","title":"2.4. Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-angle","text":"The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range.","title":"3.1. Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-initial-velocity","text":"Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) .","title":"3.2. Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-effect-of-gravity","text":"A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it.","title":"3.3. Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#improved-range-plot-with-annotations","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udccc Improved Range Plot with Annotations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-visualization","text":"We implement a computational tool to visualize the range as a function of the angle.","title":"4. Implementation: Python Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation","text":"This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion.","title":"\ud83d\ude80 Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-it-works","text":"The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion.","title":"\ud83d\udccc How It Works?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#use-cases","text":"\u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text","title":"\ud83d\udda5 Use Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-air-resistance-improved-models","text":"In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\)","title":"5. Air Resistance &amp; Improved Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualization-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing)","title":"\ud83d\udccc Visualization with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-what-does-this-code-do","text":"This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video())","title":"1\ufe0f\u20e3 What Does This Code Do?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#link-to-the-simulation-above-on-google-colab","text":"https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing","title":"Link To The Simulation Above On Google Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion","text":"The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-references-further-reading","text":"Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"8. References &amp; Further Reading"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Motivation The forced damped pendulum is a classic example of a nonlinear system exhibiting a rich spectrum of dynamic behaviors. By introducing damping and external periodic forcing, the system transitions from simple harmonic motion to more complex phenomena, such as resonance, quasiperiodicity, and chaos. Understanding these dynamics is essential in fields ranging from mechanical engineering to climate modeling and electrical circuits. The introduction of an external periodic force adds new parameters, including amplitude and frequency, which significantly affect the pendulum's motion. By varying these parameters, we can observe different behaviors, including synchronized oscillations, chaotic motion, and resonance effects. These dynamics not only illustrate fundamental physical principles but also provide practical insights into engineering applications such as energy harvesting, vibration isolation, and resonance mitigation. 2. Theoretical Foundation 2.1 Governing Differential Equation The motion of a forced damped pendulum is governed by Newton\u2019s Second Law applied to rotational motion: \\[I \\alpha = \\sum \\tau\\] For a simple pendulum of mass \\(m\\) and length \\(L\\) , the moment of inertia about the pivot is: \\[I = mL^2\\] The forces acting on the pendulum bob include: Gravitational force : Produces a restoring torque: \\[\\tau_{\\text{gravity}} = -mgL \\sin \\theta\\] Damping force : Opposes motion due to air resistance: \\[\\tau_{\\text{damping}} = -b L \\frac{d\\theta}{dt}\\] External forcing : A periodic force applied to the system: \\[\\tau_{\\text{forcing}} = F_0 L \\cos(\\omega t)\\] Applying Newton\u2019s Second Law: \\[mL^2 \\frac{d^2\\theta}{dt^2} = -mgL \\sin\\theta - b L \\frac{d\\theta}{dt} + F_0 L \\cos(\\omega t)\\] Dividing by \\(mL^2\\) , we obtain the standard form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: Natural frequency : \\[\\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damping coefficient : \\[\\gamma = \\frac{b}{mL}\\] Forcing term : \\[A = \\frac{F_0}{mL}\\] 1.2 Approximate Solutions for Small-Angle Oscillations For small angles \\(\\theta \\ll 1\\) , we use the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the equation simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This is a linear inhomogeneous second-order differential equation that can be solved using standard techniques. 1.2.1 General Solution The general solution consists of: Homogeneous solution \\(A = 0\\) , solving: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0\\] The characteristic equation is: \\[r^2 + br + \\frac{g}{L} = 0\\] Solving for \\(r\\) , the solution depends on the damping coefficient \\(b\\) : Underdamped case \\(b^2 < 4g/L\\) : \\[\\theta_h(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t))\\] where $$ omega{\\prime} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}} $$ is the damped frequency. Overdamped and critically damped cases are handled similarly but result in non-oscillatory motion. Particular solution for the forced term: \\[\\theta_p(t) = A_0 \\cos(\\omega t - \\delta)\\] where: \\[A_0 = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}}\\] and \\[\\tan\\delta = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Thus, the full solution is: \\[\\theta(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t)) + A_0 \\cos(\\omega t - \\delta)\\] where the first term decays over time, leaving only the steady-state oscillation. 1.3 Resonance Conditions and Energy Implications Resonance occurs when the driving frequency \\(\\omega\\) approaches the system\u2019s natural frequency: \\[\\omega \\approx \\sqrt{\\frac{g}{L}}\\] At resonance, the amplitude \\(A_0\\) is maximized: \\[A_{\\text{max}} \\approx \\frac{A}{b\\omega}\\] which shows that: - For small damping \\(b \\to 0\\) , the amplitude can grow excessively, leading to large oscillations. - For strong damping, resonance is suppressed, and energy is dissipated before large oscillations develop. The total energy of the system: \\[E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} mgL \\theta^2\\] is maximized at resonance, which can lead to destructive consequences in mechanical systems (e.g., bridges, buildings). Damping helps dissipate this energy and stabilize the system. 2.2 Python Visualizations import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.1 # damping coefficient (s^-1) A = 0.5 # forcing amplitude omega = np.sqrt(g / L) # driving frequency (resonance condition, rad/s) theta0 = 0.1 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) # Time settings t_max = 20.0 # total simulation time (s) dt = 0.01 # time step (s) t = np.arange(0, t_max, dt) # time array # Define the system of ODEs def pendulum_derivatives(t, state, b, g, L, A, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * theta + A * np.cos(omega * t) return np.array([dtheta_dt, dtheta_dot_dt]) # RK4 solver def rk4_step(t, state, dt, b, g, L, A, omega): k1 = pendulum_derivatives(t, state, b, g, L, A, omega) k2 = pendulum_derivatives(t + dt/2, state + dt * k1/2, b, g, L, A, omega) k3 = pendulum_derivatives(t + dt/2, state + dt * k2/2, b, g, L, A, omega) k4 = pendulum_derivatives(t + dt, state + dt * k3, b, g, L, A, omega) return state + (dt / 6) * (k1 + 2*k2 + 2*k3 + k4) # Initialize arrays state = np.array([theta0, theta_dot0]) # [theta, theta_dot] theta = np.zeros(len(t)) theta_dot = np.zeros(len(t)) theta[0], theta_dot[0] = state # Simulate the motion for i in range(1, len(t)): state = rk4_step(t[i-1], state, dt, b, g, L, A, omega) theta[i], theta_dot[i] = state # Calculate total energy m = 1.0 # mass (kg), assumed for simplicity energy = 0.5 * m * L**2 * theta_dot**2 + 0.5 * m * g * L * theta**2 # Plotting plt.figure(figsize=(12, 8)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(t, theta, label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() # Energy vs Time plt.subplot(2, 1, 2) plt.plot(t, energy, label='Total Energy', color='orange') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.title('Total Energy Over Time') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: Phase space plot plt.figure(figsize=(6, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Space: Angle vs Angular Velocity') plt.grid(True) plt.legend() plt.show() Explanation of the Code Parameters The following physical constants and initial conditions are defined with realistic values: \\(g\\) : Gravitational acceleration (m/s\u00b2). \\(L\\) : Pendulum length (m). \\(b\\) : Damping coefficient (s\u207b\u00b9). \\(A\\) : Forcing amplitude. \\(\\omega\\) : Driving frequency (rad/s), set to \\(\\omega = \\sqrt{\\frac{g}{L}}\\) to match the natural frequency for resonance. Initial conditions: \\(\\theta_0\\) : Initial angle (radians), starting the pendulum slightly displaced. \\(\\dot{\\theta}_0\\) : Initial angular velocity (rad/s). ODE Definition The pendulum_derivatives function computes the derivatives of the system: $$ \\frac{d\\theta}{dt} $$: Angular velocity. $$ \\frac{d\\dot{\\theta}}{dt} $$: Angular acceleration, based on the equation of motion. RK4 Solver The rk4_step function implements the 4th-order Runge-Kutta method to advance the solution one time step: - Numerically integrates the ODEs using four stages (k1, k2, k3, k4) to update \\(\\theta\\) and \\(\\dot{\\theta}\\) . Simulation The simulation process: - A loop iterates over time, updating: - \\(\\theta\\) : Angular displacement. - \\(\\dot{\\theta}\\) : Angular velocity. - Energy is calculated using: - $$ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} m g L \\theta^2 $$ (small-angle potential energy, in joules). Visualization The results are visualized with: - Two plots: 1. Angle \\((\\theta)\\) vs. time. 2. Energy \\((E)\\) vs. time. - A phase space plot: - \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , showing the system\u2019s trajectory in phase space. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b_values = [0.1, 0.5, 1.0] # different damping coefficients F0_values = [0.5, 1.2, 2.0] # different forcing amplitudes omega_values = [1.0, 2.0, 3.0] # different driving frequencies # Define natural frequency def omega0(L): return np.sqrt(g / L) # Define the system of equations def forced_damped_pendulum(t, y, gamma, F0, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0(L)**2 * np.sin(theta) + F0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time array t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) y0 = [0.1, 0.0] # small initial displacement # Plot motion for different parameters plt.figure(figsize=(12, 8)) for b in b_values: for F0 in F0_values: for omega in omega_values: gamma = b / L sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45', args=(gamma, F0, omega)) plt.plot(sol.t, sol.y[0], label=f'b={b}, F0={F0}, omega={omega}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion for Different Parameters') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid() plt.show() # Poincare section t_poincare = sol.t[::20] theta_poincare = sol.y[0][::20] omega_poincare = sol.y[1][::20] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='r') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation diagram driver_freqs = np.linspace(0.5, 3.0, 50) final_angles = [] for omega in driver_freqs: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45', args=(0.5, 1.2, omega)) final_angles.append(sol.y[0][-50:]) plt.figure(figsize=(8, 6)) for i, omega in enumerate(driver_freqs): plt.scatter([omega] * len(final_angles[i]), final_angles[i], s=1, color='b') plt.xlabel('Driving Frequency (rad/s)') plt.ylabel('Final Angles (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() # Discussion on Model Limitations and Extensions # Limitations: # - Small-angle approximations do not hold for chaotic motion. # - Linear damping may not accurately reflect real-world air resistance. # - External forcing may not always be purely periodic. # Extensions: # - Nonlinear damping effects can be incorporated (e.g., quadratic drag). # - Stochastic forcing can be introduced to model real-world perturbations. # - Multi-degree-of-freedom systems can be explored for coupled oscillators. Forced Damped Pendulum Simulation This Python code simulates a forced damped pendulum and visualizes its behavior using NumPy, Matplotlib, and SciPy. Here's a concise explanation: Setup Defines parameters: - Gravity: \\(g=9.81,\\text{m/s}^2\\) - Pendulum length: \\(L=1.0,\\text{m}\\) - Damping coefficients: \\(b\\) - Forcing amplitudes: \\(F_0\\) - Driving frequencies: \\(\\omega\\) - Natural frequency: \\(\\omega_0=\\sqrt{\\frac{g}{L}}\\) Equations Models the pendulum with the ODE: - \\(\\frac{d^2\\theta}{dt^2}=-\\gamma\\dot{\\theta}-\\omega_0^2\\sin(\\theta)+F_0\\cos(\\omega t)\\) Split into two first-order equations: - Angle: \\(\\theta\\) - Angular velocity: \\(\\dot{\\theta}\\) Simulation Uses solve_ivp with the RK45 method to solve the ODE over 50 seconds. Initial condition: Small angle (0.1 rad). Plots Motion : Graphs \\(\\theta(t)\\) for combinations of \\(b\\) , \\(F_0\\) , and \\(\\omega\\) . Phase Portrait : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for one case. Poincar\u00e9 Section : Scatters \\(\\theta\\) and \\(\\dot{\\theta}\\) every 20th point. Bifurcation Diagram : Shows final \\(\\theta\\) values vs. driving frequency ( \\(\\omega\\) ). Discussion Limitations : No small-angle approximation. Linear damping may not reflect real-world conditions. Extensions : Nonlinear damping (e.g., quadratic drag). Stochastic forcing for real-world perturbations. HTML Simulation For Further Implementation What It Does This Python script creates an interactive web-based simulation of a forced damped pendulum . It: Generates an HTML file ( pendulum_simulation.html ) with a canvas showing a pendulum and a chart plotting its motion. Lets you adjust parameters (damping, driving amplitude, frequency) via sliders and start/stop the simulation with buttons. Simulates the pendulum\u2019s motion under gravity, damping, and an external driving force. How It Works Structure The code defines html_content as a triple-quoted string containing HTML, CSS, JavaScript, and Brython Python. It writes this string to pendulum_simulation.html and saves it. Components HTML/CSS : Sets up the webpage layout with sliders, buttons, a pendulum canvas, and a chart canvas. Brython : Runs Python in the browser (loaded via CDN), handling the simulation logic. Chart.js : Plots the pendulum\u2019s angular displacement over time. Simulation Logic Physics : Uses the Runge-Kutta 4 (RK4) method to solve differential equations for a damped, driven pendulum: dx_dt : Calculates angular velocity and acceleration based on gravity, damping, and driving force. rk4_step : Updates the pendulum\u2019s angle ( theta ) and velocity ( omega ) every time step ( dt = 0.01s ). Animation : The animate() function updates the pendulum\u2019s position, redraws it on the canvas, and updates the chart every 10ms (if running = True ). Interactivity Sliders : updateParams() adjusts b (damping), F_d (driving amplitude), and omega_d (driving frequency) in real-time. Buttons : startSimulation() resets variables and starts the animation loop. stopSimulation() pauses it by setting running = False . Execution Run the Python script to create the HTML file. Open the HTML file in a browser, where Brython executes the embedded Python, simulating the pendulum and responding to user input. from IPython.display import HTML # Define the HTML content html_content = \"\"\" <!DOCTYPE html> <html> <head> <title>Forced Damped Pendulum Simulation</title> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.0/brython.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.0/brython_stdlib.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js\"></script> <style> body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; } .container { margin: 20px auto; max-width: 800px; } canvas { border: 1px solid black; margin: 10px; } .controls { margin: 20px 0; } .controls label { margin-right: 10px; } </style> </head> <body onload=\"brython()\"> <div class=\"container\"> <h1>Forced Damped Pendulum Simulation</h1> <div class=\"controls\"> <label>Damping Coefficient (b): <input type=\"range\" id=\"damping\" min=\"0\" max=\"0.2\" step=\"0.01\" value=\"0.05\" oninput=\"updateParams()\"></label> <span id=\"dampingValue\">0.05</span><br> <label>Driving Amplitude (F_d): <input type=\"range\" id=\"drivingAmplitude\" min=\"0\" max=\"1.5\" step=\"0.1\" value=\"0.5\" oninput=\"updateParams()\"></label> <span id=\"drivingAmplitudeValue\">0.5</span><br> <label>Driving Frequency (\u03c9_d): <input type=\"range\" id=\"drivingFrequency\" min=\"0\" max=\"5\" step=\"0.1\" value=\"3.13\" oninput=\"updateParams()\"></label> <span id=\"drivingFrequencyValue\">3.13</span><br> <button onclick=\"startSimulation()\">Start Simulation</button> <button onclick=\"stopSimulation()\">Stop Simulation</button> </div> <canvas id=\"pendulumCanvas\" width=\"400\" height=\"400\"></canvas> <canvas id=\"chartCanvas\" width=\"400\" height=\"200\"></canvas> </div> <script type=\"text/python\"> from browser import document, window, timer import math # Constants g = 9.81 # Acceleration due to gravity (m/s^2) L = 1.0 # Length of pendulum (m) m = 0.1 # Mass of the bob (kg) dt = 0.01 # Time step (s) theta_0 = 0.1 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity (radians/s) omega_natural = math.sqrt(g / L) # Global variables b = 0.05 # Damping coefficient F_d = 0.5 # Driving amplitude omega_d = 3.13 # Driving frequency (near resonance) theta = theta_0 omega = omega_0 t = 0.0 time_data = [] theta_data = [] running = False # Canvas and Chart setup canvas = document[\"pendulumCanvas\"] ctx = canvas.getContext(\"2d\") chartCanvas = document[\"chartCanvas\"] chartCtx = chartCanvas.getContext(\"2d\") chart = window.Chart.new(chartCtx, { \"type\": \"line\", \"data\": { \"labels\": [], \"datasets\": [{ \"label\": \"Angular Displacement (radians)\", \"data\": [], \"borderColor\": \"blue\", \"fill\": False }] }, \"options\": { \"scales\": { \"x\": {\"title\": {\"display\": True, \"text\": \"Time (s)\"}}, \"y\": {\"title\": {\"display\": True, \"text\": \"\u03b8 (radians)\"}} } } }) # Differential equations def dx_dt(x, t): theta, omega = x dtheta_dt = omega domega_dt = -(b / (m * L)) * omega - (g / L) * math.sin(theta) + (F_d / (m * L)) * math.sin(omega_d * t) return [dtheta_dt, domega_dt] # RK4 step def rk4_step(x, t): k1 = dx_dt(x, t) k2 = dx_dt([x[0] + k1[0] * dt / 2, x[1] + k1[1] * dt / 2], t + dt / 2) k3 = dx_dt([x[0] + k2[0] * dt / 2, x[1] + k2[1] * dt / 2], t + dt / 2) k4 = dx_dt([x[0] + k3[0] * dt, x[1] + k3[1] * dt], t + dt) x_new = [x[0] + (dt / 6) * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]), x[1] + (dt / 6) * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1])] return x_new # Update parameters from sliders def updateParams(ev=None): global b, F_d, omega_d b = float(document[\"damping\"].value) F_d = float(document[\"drivingAmplitude\"].value) omega_d = float(document[\"drivingFrequency\"].value) document[\"dampingValue\"].text = f\"{b:.2f}\" document[\"drivingAmplitudeValue\"].text = f\"{F_d:.1f}\" document[\"drivingFrequencyValue\"].text = f\"{omega_d:.2f}\" # Animation function def animate(): global theta, omega, t, running if not running: return # Update position using RK4 x = [theta, omega] x_new = rk4_step(x, t) theta, omega = x_new t += dt # Update canvas (draw pendulum) ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.beginPath() pivot_x, pivot_y = canvas.width / 2, 50 bob_x = pivot_x + 150 * math.sin(theta) # Scaled length for visibility bob_y = pivot_y + 150 * math.cos(theta) ctx.moveTo(pivot_x, pivot_y) ctx.lineTo(bob_x, bob_y) ctx.strokeStyle = \"black\" ctx.lineWidth = 2 ctx.stroke() ctx.beginPath() ctx.arc(bob_x, bob_y, 10, 0, 2 * math.pi) ctx.fillStyle = \"red\" ctx.fill() # Update chart time_data.append(t) theta_data.append(theta) if len(time_data) > 200: # Limit data points for performance time_data.pop(0) theta_data.pop(0) chart.data.labels = [f\"{t:.1f}\" for t in time_data] chart.data.datasets[0].data = theta_data chart.update() # Schedule next frame timer.set_timeout(animate, 10) # Start and stop functions def startSimulation(ev=None): global running, t, theta, omega, time_data, theta_data if not running: running = True t = 0.0 theta = theta_0 omega = omega_0 time_data = [] theta_data = [] animate() def stopSimulation(ev=None): global running running = False # Bind functions to window for JavaScript calls window.startSimulation = startSimulation window.stopSimulation = stopSimulation window.updateParams = updateParams # Initial parameter update updateParams() </script> </body> </html> \"\"\" # Display the HTML in Jupyter HTML(html_content) 3. Analysis of Dynamics 3.1 Influence of Parameters Damping coefficient \\((\\gamma)\\) : High damping suppresses oscillations. Low damping allows oscillations to persist longer. Driving force amplitude \\(( A )\\) : Larger $ A $ can lead to chaotic motion. Driving frequency \\(( \\omega )\\) : At \\(\\omega \\approx \\omega_0\\) , resonance occurs. For high \\(\\omega\\) , behavior becomes irregular. 3.2 Transition to Chaos As forcing increases, the system moves from periodic motion to quasiperiodic and eventually chaotic behavior. This is analyzed using: - Phase portraits (visualizing velocity vs. displacement) - Poincar\u00e9 sections (snapshots at regular time intervals) - Bifurcation diagrams (tracking equilibrium solutions as parameters vary) 4. Practical Applications Energy Harvesting : Piezoelectric pendulums convert oscillations into electrical energy. Suspension Bridges : Understanding resonance prevents structural failures. Electrical Circuits : Analogous to forced RLC circuits. Biomechanics : Gait patterns modeled using pendulum dynamics. 5. Computational Implementation 5.1 Numerical Simulation The forced damped pendulum equation is solved using numerical integration (Runge-Kutta method). The code generates: - Motion plots for varying parameters. - Phase portraits to visualize periodic and chaotic behavior. - Poincar\u00e9 sections for transition analysis. - Bifurcation diagrams to study nonlinear effects. 5.2 Model Limitations & Extensions Limitations : Small-angle approximations break down at large amplitudes. Linear damping does not always accurately model real-world resistance. External forcing is not always purely periodic. Extensions : Nonlinear damping (e.g., quadratic drag) can be incorporated. Stochastic forcing to simulate real-world perturbations. Coupled oscillators for multi-degree-of-freedom systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-motivation","text":"The forced damped pendulum is a classic example of a nonlinear system exhibiting a rich spectrum of dynamic behaviors. By introducing damping and external periodic forcing, the system transitions from simple harmonic motion to more complex phenomena, such as resonance, quasiperiodicity, and chaos. Understanding these dynamics is essential in fields ranging from mechanical engineering to climate modeling and electrical circuits. The introduction of an external periodic force adds new parameters, including amplitude and frequency, which significantly affect the pendulum's motion. By varying these parameters, we can observe different behaviors, including synchronized oscillations, chaotic motion, and resonance effects. These dynamics not only illustrate fundamental physical principles but also provide practical insights into engineering applications such as energy harvesting, vibration isolation, and resonance mitigation.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-governing-differential-equation","text":"The motion of a forced damped pendulum is governed by Newton\u2019s Second Law applied to rotational motion: \\[I \\alpha = \\sum \\tau\\] For a simple pendulum of mass \\(m\\) and length \\(L\\) , the moment of inertia about the pivot is: \\[I = mL^2\\] The forces acting on the pendulum bob include: Gravitational force : Produces a restoring torque: \\[\\tau_{\\text{gravity}} = -mgL \\sin \\theta\\] Damping force : Opposes motion due to air resistance: \\[\\tau_{\\text{damping}} = -b L \\frac{d\\theta}{dt}\\] External forcing : A periodic force applied to the system: \\[\\tau_{\\text{forcing}} = F_0 L \\cos(\\omega t)\\] Applying Newton\u2019s Second Law: \\[mL^2 \\frac{d^2\\theta}{dt^2} = -mgL \\sin\\theta - b L \\frac{d\\theta}{dt} + F_0 L \\cos(\\omega t)\\] Dividing by \\(mL^2\\) , we obtain the standard form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: Natural frequency : \\[\\omega_0 = \\sqrt{\\frac{g}{L}}\\] Damping coefficient : \\[\\gamma = \\frac{b}{mL}\\] Forcing term : \\[A = \\frac{F_0}{mL}\\]","title":"2.1 Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-approximate-solutions-for-small-angle-oscillations","text":"For small angles \\(\\theta \\ll 1\\) , we use the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the equation simplifies it to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This is a linear inhomogeneous second-order differential equation that can be solved using standard techniques.","title":"1.2 Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#121-general-solution","text":"The general solution consists of: Homogeneous solution \\(A = 0\\) , solving: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0\\] The characteristic equation is: \\[r^2 + br + \\frac{g}{L} = 0\\] Solving for \\(r\\) , the solution depends on the damping coefficient \\(b\\) : Underdamped case \\(b^2 < 4g/L\\) : \\[\\theta_h(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t))\\] where $$ omega{\\prime} = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}} $$ is the damped frequency. Overdamped and critically damped cases are handled similarly but result in non-oscillatory motion. Particular solution for the forced term: \\[\\theta_p(t) = A_0 \\cos(\\omega t - \\delta)\\] where: \\[A_0 = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}}\\] and \\[\\tan\\delta = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Thus, the full solution is: \\[\\theta(t) = e^{-bt/2} (C_1 \\cos(\\omega{\\prime} t) + C_2 \\sin(\\omega{\\prime} t)) + A_0 \\cos(\\omega t - \\delta)\\] where the first term decays over time, leaving only the steady-state oscillation.","title":"1.2.1 General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance-conditions-and-energy-implications","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the system\u2019s natural frequency: \\[\\omega \\approx \\sqrt{\\frac{g}{L}}\\] At resonance, the amplitude \\(A_0\\) is maximized: \\[A_{\\text{max}} \\approx \\frac{A}{b\\omega}\\] which shows that: - For small damping \\(b \\to 0\\) , the amplitude can grow excessively, leading to large oscillations. - For strong damping, resonance is suppressed, and energy is dissipated before large oscillations develop. The total energy of the system: \\[E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} mgL \\theta^2\\] is maximized at resonance, which can lead to destructive consequences in mechanical systems (e.g., bridges, buildings). Damping helps dissipate this energy and stabilize the system.","title":"1.3 Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-python-visualizations","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.1 # damping coefficient (s^-1) A = 0.5 # forcing amplitude omega = np.sqrt(g / L) # driving frequency (resonance condition, rad/s) theta0 = 0.1 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) # Time settings t_max = 20.0 # total simulation time (s) dt = 0.01 # time step (s) t = np.arange(0, t_max, dt) # time array # Define the system of ODEs def pendulum_derivatives(t, state, b, g, L, A, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * theta + A * np.cos(omega * t) return np.array([dtheta_dt, dtheta_dot_dt]) # RK4 solver def rk4_step(t, state, dt, b, g, L, A, omega): k1 = pendulum_derivatives(t, state, b, g, L, A, omega) k2 = pendulum_derivatives(t + dt/2, state + dt * k1/2, b, g, L, A, omega) k3 = pendulum_derivatives(t + dt/2, state + dt * k2/2, b, g, L, A, omega) k4 = pendulum_derivatives(t + dt, state + dt * k3, b, g, L, A, omega) return state + (dt / 6) * (k1 + 2*k2 + 2*k3 + k4) # Initialize arrays state = np.array([theta0, theta_dot0]) # [theta, theta_dot] theta = np.zeros(len(t)) theta_dot = np.zeros(len(t)) theta[0], theta_dot[0] = state # Simulate the motion for i in range(1, len(t)): state = rk4_step(t[i-1], state, dt, b, g, L, A, omega) theta[i], theta_dot[i] = state # Calculate total energy m = 1.0 # mass (kg), assumed for simplicity energy = 0.5 * m * L**2 * theta_dot**2 + 0.5 * m * g * L * theta**2 # Plotting plt.figure(figsize=(12, 8)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(t, theta, label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.legend() # Energy vs Time plt.subplot(2, 1, 2) plt.plot(t, energy, label='Total Energy', color='orange') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.title('Total Energy Over Time') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: Phase space plot plt.figure(figsize=(6, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Space: Angle vs Angular Velocity') plt.grid(True) plt.legend() plt.show()","title":"2.2 Python Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation-of-the-code","text":"","title":"Explanation of the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"The following physical constants and initial conditions are defined with realistic values: \\(g\\) : Gravitational acceleration (m/s\u00b2). \\(L\\) : Pendulum length (m). \\(b\\) : Damping coefficient (s\u207b\u00b9). \\(A\\) : Forcing amplitude. \\(\\omega\\) : Driving frequency (rad/s), set to \\(\\omega = \\sqrt{\\frac{g}{L}}\\) to match the natural frequency for resonance. Initial conditions: \\(\\theta_0\\) : Initial angle (radians), starting the pendulum slightly displaced. \\(\\dot{\\theta}_0\\) : Initial angular velocity (rad/s).","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#ode-definition","text":"The pendulum_derivatives function computes the derivatives of the system: $$ \\frac{d\\theta}{dt} $$: Angular velocity. $$ \\frac{d\\dot{\\theta}}{dt} $$: Angular acceleration, based on the equation of motion.","title":"ODE Definition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#rk4-solver","text":"The rk4_step function implements the 4th-order Runge-Kutta method to advance the solution one time step: - Numerically integrates the ODEs using four stages (k1, k2, k3, k4) to update \\(\\theta\\) and \\(\\dot{\\theta}\\) .","title":"RK4 Solver"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation","text":"The simulation process: - A loop iterates over time, updating: - \\(\\theta\\) : Angular displacement. - \\(\\dot{\\theta}\\) : Angular velocity. - Energy is calculated using: - $$ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + \\frac{1}{2} m g L \\theta^2 $$ (small-angle potential energy, in joules).","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"The results are visualized with: - Two plots: 1. Angle \\((\\theta)\\) vs. time. 2. Energy \\((E)\\) vs. time. - A phase space plot: - \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , showing the system\u2019s trajectory in phase space. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b_values = [0.1, 0.5, 1.0] # different damping coefficients F0_values = [0.5, 1.2, 2.0] # different forcing amplitudes omega_values = [1.0, 2.0, 3.0] # different driving frequencies # Define natural frequency def omega0(L): return np.sqrt(g / L) # Define the system of equations def forced_damped_pendulum(t, y, gamma, F0, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0(L)**2 * np.sin(theta) + F0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time array t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) y0 = [0.1, 0.0] # small initial displacement # Plot motion for different parameters plt.figure(figsize=(12, 8)) for b in b_values: for F0 in F0_values: for omega in omega_values: gamma = b / L sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45', args=(gamma, F0, omega)) plt.plot(sol.t, sol.y[0], label=f'b={b}, F0={F0}, omega={omega}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion for Different Parameters') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid() plt.show() # Poincare section t_poincare = sol.t[::20] theta_poincare = sol.y[0][::20] omega_poincare = sol.y[1][::20] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='r') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() # Bifurcation diagram driver_freqs = np.linspace(0.5, 3.0, 50) final_angles = [] for omega in driver_freqs: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45', args=(0.5, 1.2, omega)) final_angles.append(sol.y[0][-50:]) plt.figure(figsize=(8, 6)) for i, omega in enumerate(driver_freqs): plt.scatter([omega] * len(final_angles[i]), final_angles[i], s=1, color='b') plt.xlabel('Driving Frequency (rad/s)') plt.ylabel('Final Angles (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() # Discussion on Model Limitations and Extensions # Limitations: # - Small-angle approximations do not hold for chaotic motion. # - Linear damping may not accurately reflect real-world air resistance. # - External forcing may not always be purely periodic. # Extensions: # - Nonlinear damping effects can be incorporated (e.g., quadratic drag). # - Stochastic forcing can be introduced to model real-world perturbations. # - Multi-degree-of-freedom systems can be explored for coupled oscillators.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-simulation","text":"This Python code simulates a forced damped pendulum and visualizes its behavior using NumPy, Matplotlib, and SciPy. Here's a concise explanation:","title":"Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#setup","text":"Defines parameters: - Gravity: \\(g=9.81,\\text{m/s}^2\\) - Pendulum length: \\(L=1.0,\\text{m}\\) - Damping coefficients: \\(b\\) - Forcing amplitudes: \\(F_0\\) - Driving frequencies: \\(\\omega\\) - Natural frequency: \\(\\omega_0=\\sqrt{\\frac{g}{L}}\\)","title":"Setup"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equations","text":"Models the pendulum with the ODE: - \\(\\frac{d^2\\theta}{dt^2}=-\\gamma\\dot{\\theta}-\\omega_0^2\\sin(\\theta)+F_0\\cos(\\omega t)\\) Split into two first-order equations: - Angle: \\(\\theta\\) - Angular velocity: \\(\\dot{\\theta}\\)","title":"Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation_1","text":"Uses solve_ivp with the RK45 method to solve the ODE over 50 seconds. Initial condition: Small angle (0.1 rad).","title":"Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plots","text":"Motion : Graphs \\(\\theta(t)\\) for combinations of \\(b\\) , \\(F_0\\) , and \\(\\omega\\) . Phase Portrait : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for one case. Poincar\u00e9 Section : Scatters \\(\\theta\\) and \\(\\dot{\\theta}\\) every 20th point. Bifurcation Diagram : Shows final \\(\\theta\\) values vs. driving frequency ( \\(\\omega\\) ).","title":"Plots"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#discussion","text":"Limitations : No small-angle approximation. Linear damping may not reflect real-world conditions. Extensions : Nonlinear damping (e.g., quadratic drag). Stochastic forcing for real-world perturbations.","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#html-simulation-for-further-implementation","text":"","title":"HTML Simulation For Further Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#what-it-does","text":"This Python script creates an interactive web-based simulation of a forced damped pendulum . It: Generates an HTML file ( pendulum_simulation.html ) with a canvas showing a pendulum and a chart plotting its motion. Lets you adjust parameters (damping, driving amplitude, frequency) via sliders and start/stop the simulation with buttons. Simulates the pendulum\u2019s motion under gravity, damping, and an external driving force.","title":"What It Does"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#how-it-works","text":"","title":"How It Works"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#structure","text":"The code defines html_content as a triple-quoted string containing HTML, CSS, JavaScript, and Brython Python. It writes this string to pendulum_simulation.html and saves it.","title":"Structure"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#components","text":"HTML/CSS : Sets up the webpage layout with sliders, buttons, a pendulum canvas, and a chart canvas. Brython : Runs Python in the browser (loaded via CDN), handling the simulation logic. Chart.js : Plots the pendulum\u2019s angular displacement over time.","title":"Components"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-logic","text":"Physics : Uses the Runge-Kutta 4 (RK4) method to solve differential equations for a damped, driven pendulum: dx_dt : Calculates angular velocity and acceleration based on gravity, damping, and driving force. rk4_step : Updates the pendulum\u2019s angle ( theta ) and velocity ( omega ) every time step ( dt = 0.01s ). Animation : The animate() function updates the pendulum\u2019s position, redraws it on the canvas, and updates the chart every 10ms (if running = True ).","title":"Simulation Logic"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#interactivity","text":"Sliders : updateParams() adjusts b (damping), F_d (driving amplitude), and omega_d (driving frequency) in real-time. Buttons : startSimulation() resets variables and starts the animation loop. stopSimulation() pauses it by setting running = False .","title":"Interactivity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#execution","text":"Run the Python script to create the HTML file. Open the HTML file in a browser, where Brython executes the embedded Python, simulating the pendulum and responding to user input. from IPython.display import HTML # Define the HTML content html_content = \"\"\" <!DOCTYPE html> <html> <head> <title>Forced Damped Pendulum Simulation</title> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.0/brython.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.0/brython_stdlib.js\"></script> <script src=\"https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js\"></script> <style> body { font-family: Arial, sans-serif; text-align: center; background-color: #f0f0f0; } .container { margin: 20px auto; max-width: 800px; } canvas { border: 1px solid black; margin: 10px; } .controls { margin: 20px 0; } .controls label { margin-right: 10px; } </style> </head> <body onload=\"brython()\"> <div class=\"container\"> <h1>Forced Damped Pendulum Simulation</h1> <div class=\"controls\"> <label>Damping Coefficient (b): <input type=\"range\" id=\"damping\" min=\"0\" max=\"0.2\" step=\"0.01\" value=\"0.05\" oninput=\"updateParams()\"></label> <span id=\"dampingValue\">0.05</span><br> <label>Driving Amplitude (F_d): <input type=\"range\" id=\"drivingAmplitude\" min=\"0\" max=\"1.5\" step=\"0.1\" value=\"0.5\" oninput=\"updateParams()\"></label> <span id=\"drivingAmplitudeValue\">0.5</span><br> <label>Driving Frequency (\u03c9_d): <input type=\"range\" id=\"drivingFrequency\" min=\"0\" max=\"5\" step=\"0.1\" value=\"3.13\" oninput=\"updateParams()\"></label> <span id=\"drivingFrequencyValue\">3.13</span><br> <button onclick=\"startSimulation()\">Start Simulation</button> <button onclick=\"stopSimulation()\">Stop Simulation</button> </div> <canvas id=\"pendulumCanvas\" width=\"400\" height=\"400\"></canvas> <canvas id=\"chartCanvas\" width=\"400\" height=\"200\"></canvas> </div> <script type=\"text/python\"> from browser import document, window, timer import math # Constants g = 9.81 # Acceleration due to gravity (m/s^2) L = 1.0 # Length of pendulum (m) m = 0.1 # Mass of the bob (kg) dt = 0.01 # Time step (s) theta_0 = 0.1 # Initial angle (radians) omega_0 = 0.0 # Initial angular velocity (radians/s) omega_natural = math.sqrt(g / L) # Global variables b = 0.05 # Damping coefficient F_d = 0.5 # Driving amplitude omega_d = 3.13 # Driving frequency (near resonance) theta = theta_0 omega = omega_0 t = 0.0 time_data = [] theta_data = [] running = False # Canvas and Chart setup canvas = document[\"pendulumCanvas\"] ctx = canvas.getContext(\"2d\") chartCanvas = document[\"chartCanvas\"] chartCtx = chartCanvas.getContext(\"2d\") chart = window.Chart.new(chartCtx, { \"type\": \"line\", \"data\": { \"labels\": [], \"datasets\": [{ \"label\": \"Angular Displacement (radians)\", \"data\": [], \"borderColor\": \"blue\", \"fill\": False }] }, \"options\": { \"scales\": { \"x\": {\"title\": {\"display\": True, \"text\": \"Time (s)\"}}, \"y\": {\"title\": {\"display\": True, \"text\": \"\u03b8 (radians)\"}} } } }) # Differential equations def dx_dt(x, t): theta, omega = x dtheta_dt = omega domega_dt = -(b / (m * L)) * omega - (g / L) * math.sin(theta) + (F_d / (m * L)) * math.sin(omega_d * t) return [dtheta_dt, domega_dt] # RK4 step def rk4_step(x, t): k1 = dx_dt(x, t) k2 = dx_dt([x[0] + k1[0] * dt / 2, x[1] + k1[1] * dt / 2], t + dt / 2) k3 = dx_dt([x[0] + k2[0] * dt / 2, x[1] + k2[1] * dt / 2], t + dt / 2) k4 = dx_dt([x[0] + k3[0] * dt, x[1] + k3[1] * dt], t + dt) x_new = [x[0] + (dt / 6) * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]), x[1] + (dt / 6) * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1])] return x_new # Update parameters from sliders def updateParams(ev=None): global b, F_d, omega_d b = float(document[\"damping\"].value) F_d = float(document[\"drivingAmplitude\"].value) omega_d = float(document[\"drivingFrequency\"].value) document[\"dampingValue\"].text = f\"{b:.2f}\" document[\"drivingAmplitudeValue\"].text = f\"{F_d:.1f}\" document[\"drivingFrequencyValue\"].text = f\"{omega_d:.2f}\" # Animation function def animate(): global theta, omega, t, running if not running: return # Update position using RK4 x = [theta, omega] x_new = rk4_step(x, t) theta, omega = x_new t += dt # Update canvas (draw pendulum) ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.beginPath() pivot_x, pivot_y = canvas.width / 2, 50 bob_x = pivot_x + 150 * math.sin(theta) # Scaled length for visibility bob_y = pivot_y + 150 * math.cos(theta) ctx.moveTo(pivot_x, pivot_y) ctx.lineTo(bob_x, bob_y) ctx.strokeStyle = \"black\" ctx.lineWidth = 2 ctx.stroke() ctx.beginPath() ctx.arc(bob_x, bob_y, 10, 0, 2 * math.pi) ctx.fillStyle = \"red\" ctx.fill() # Update chart time_data.append(t) theta_data.append(theta) if len(time_data) > 200: # Limit data points for performance time_data.pop(0) theta_data.pop(0) chart.data.labels = [f\"{t:.1f}\" for t in time_data] chart.data.datasets[0].data = theta_data chart.update() # Schedule next frame timer.set_timeout(animate, 10) # Start and stop functions def startSimulation(ev=None): global running, t, theta, omega, time_data, theta_data if not running: running = True t = 0.0 theta = theta_0 omega = omega_0 time_data = [] theta_data = [] animate() def stopSimulation(ev=None): global running running = False # Bind functions to window for JavaScript calls window.startSimulation = startSimulation window.stopSimulation = stopSimulation window.updateParams = updateParams # Initial parameter update updateParams() </script> </body> </html> \"\"\" # Display the HTML in Jupyter HTML(html_content)","title":"Execution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-analysis-of-dynamics","text":"","title":"3. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-influence-of-parameters","text":"Damping coefficient \\((\\gamma)\\) : High damping suppresses oscillations. Low damping allows oscillations to persist longer. Driving force amplitude \\(( A )\\) : Larger $ A $ can lead to chaotic motion. Driving frequency \\(( \\omega )\\) : At \\(\\omega \\approx \\omega_0\\) , resonance occurs. For high \\(\\omega\\) , behavior becomes irregular.","title":"3.1 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-transition-to-chaos","text":"As forcing increases, the system moves from periodic motion to quasiperiodic and eventually chaotic behavior. This is analyzed using: - Phase portraits (visualizing velocity vs. displacement) - Poincar\u00e9 sections (snapshots at regular time intervals) - Bifurcation diagrams (tracking equilibrium solutions as parameters vary)","title":"3.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-practical-applications","text":"Energy Harvesting : Piezoelectric pendulums convert oscillations into electrical energy. Suspension Bridges : Understanding resonance prevents structural failures. Electrical Circuits : Analogous to forced RLC circuits. Biomechanics : Gait patterns modeled using pendulum dynamics.","title":"4. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-computational-implementation","text":"","title":"5. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-numerical-simulation","text":"The forced damped pendulum equation is solved using numerical integration (Runge-Kutta method). The code generates: - Motion plots for varying parameters. - Phase portraits to visualize periodic and chaotic behavior. - Poincar\u00e9 sections for transition analysis. - Bifurcation diagrams to study nonlinear effects.","title":"5.1 Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-model-limitations-extensions","text":"","title":"5.2 Model Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Small-angle approximations break down at large amplitudes. Linear damping does not always accurately model real-world resistance. External forcing is not always purely periodic.","title":"Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Nonlinear damping (e.g., quadratic drag) can be incorporated. Stochastic forcing to simulate real-world perturbations. Coupled oscillators for multi-degree-of-freedom systems.","title":"Extensions:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law states that the square of the orbital period \\((T^2)\\) of a planet is proportional to the cube of its semi-major axis \\((r^3)\\) . This fundamental principle in celestial mechanics is derived from Newton\u2019s Law of Universal Gravitation and centripetal force equilibrium in circular orbits. This document will: - Derive the relationship between \\((T^2)\\) and \\((r^3)\\) . - Discuss its implications in astronomy. - Implement a computational model for circular orbits. - Visualize the relationship between \\((T^2)\\) and \\((r^3)\\) . Derivation of Kepler\u2019s Third Law for Circular Orbits We start with Newton\u2019s Law of Universal Gravitation , which states that the gravitational force between two masses \\((m)\\) and \\((M)\\) is: \\[ F = \\frac{G M m}{r^2} \\] where: - \\((G)\\) is the gravitational constant \\((6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})\\) , - \\((M)\\) is the mass of the central body (e.g., the Sun for planetary orbits), - \\((m)\\) is the orbiting mass, - \\((r)\\) is the orbital radius. For a circular orbit, the centripetal force required to maintain the orbit is: \\[ F = m \\frac{v^2}{r} \\] where: - \\((v)\\) is the orbital velocity. Setting gravitational force equal to centripetal force: \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] Canceling \\((m)\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Rearranging for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\((T)\\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\((v)\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\] Rewriting: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] Implications of Kepler\u2019s Third Law in Astronomy The relationship \\[ T^2 \\propto r^3 \\] derived from Kepler\u2019s Third Law has profound implications in astronomy, particularly in determining planetary masses, calculating distances, and understanding celestial mechanics. Below are some key applications: 1. Determining the Mass of Celestial Bodies By rewriting Kepler\u2019s Third Law in terms of mass: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] we can calculate the mass of a central body (e.g., a planet or star) if we know the orbital period and orbital radius of a smaller orbiting object. Example: Finding the Mass of the Sun Using Earth\u2019s orbit around the Sun: - $ r = 1.496 \\times 10^{11} \\, \\text{m} $ (1 AU), - $ T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s} $, - $ G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $. Plugging these values in: \\[ M_{\\odot} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\] \\[ M_{\\odot} \\approx 1.989 \\times 10^{30} \\, \\text{kg} \\] This matches the known mass of the Sun. Similarly, the mass of planets can be determined by observing their moons. 2. Estimating the Distance to Planets and Moons Since we know that: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] if we measure the orbital period of a satellite or planet, we can calculate its distance from the central body: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] Example: Measuring the Distance of Jupiter\u2019s Moons Galileo\u2019s observations of Jupiter\u2019s moons led to estimates of their orbital radii. By measuring their orbital periods, astronomers calculated their distances from Jupiter. This method applies to exoplanets\u2014measuring the transit time of a planet around a distant star helps estimate its orbital radius. 3. Predicting the Motion of Satellites and Spacecraft Kepler\u2019s Law governs how satellites orbit Earth. Space agencies use it to calculate fuel needs and plan satellite deployments. Geostationary satellites (e.g., GPS satellites) are placed in orbits where their period matches Earth\u2019s rotation ($ T = 24 \\, \\text{hours} $), ensuring they stay fixed above one location. Using $ T^2 \\propto r^3 $, we can determine the correct altitude needed for stable satellite orbits. For a geostationary orbit: \\[ r = \\left( \\frac{G M_{\\text{Earth}} (24 \\times 3600)^2}{4\\pi^2} \\right)^{1/3} \\approx 4.22 \\times 10^7 \\, \\text{m} \\] This corresponds to an altitude of about 35,786 km above Earth\u2019s equator. 4. Exoplanet Discovery and Characterization The radial velocity method and transit method both rely on Kepler\u2019s Third Law to determine exoplanet orbits. Transit Method : When a planet passes in front of a star, its orbital period $ T $ can be measured. Radial Velocity Method : By observing how a star wobbles due to gravitational interaction, astronomers infer a planet\u2019s mass and distance. Example: Kepler Space Telescope Discoveries NASA\u2019s Kepler telescope discovered thousands of exoplanets by measuring orbital periods and applying Kepler\u2019s Law to estimate planetary distances from their stars: \\[ r = \\left( \\frac{G M_{\\text{star}} T^2}{4\\pi^2} \\right)^{1/3} \\] 5. Binary Star Systems and Black Hole Masses Kepler\u2019s Third Law extends to binary star systems, where two stars orbit a common center of mass. The total mass of the system is: \\[ M_1 + M_2 = \\frac{4\\pi^2 r^3}{G T^2} \\] By measuring the orbital period and separation distance, astronomers determine the combined mass of both stars. This is one of the main methods used to detect stellar-mass black holes by observing their interaction with a companion star. Example: Cygnus X-1 Black Hole By applying Kepler\u2019s Law to the orbit of a star around an unseen object, astronomers confirmed the presence of a black hole with a mass of approximately $ 21 M_{\\odot} $. 6. Understanding the Structure of the Solar System and Galaxies Orbital mechanics of planets, moons, and asteroids are explained using Kepler\u2019s Third Law. The orbital speeds of stars around galaxies deviate from predictions, providing evidence for dark matter. Example: Dark Matter Evidence Kepler\u2019s Law predicts that stars farther from a galaxy\u2019s center should orbit more slowly, with velocity scaling as: \\[ v \\propto \\frac{1}{\\sqrt{r}} \\] Observations show that they orbit faster than expected (a flat rotation curve), leading to the hypothesis of dark matter contributing additional mass: \\[ M_{\\text{total}} = \\frac{v^2 r}{G} \\] This discrepancy suggests unseen mass influencing gravitational dynamics. This Markdown document is now properly formatted with LaTeX for equations, clear section headings, and consistent notation. It\u2019s ready for use in platforms like GitHub, Jupyter Notebook, or other Markdown renderers. Let me know if you\u2019d like further adjustments! Real-World Example: Moon\u2019s Orbit Around Earth The Moon\u2019s orbit around Earth follows Kepler\u2019s Third Law. Given: - Earth\u2019s mass \\((M = 5.972 \\times 10^{24} \\text{ kg})\\) , - Orbital radius of the Moon \\((r \\approx 3.844 \\times 10^8 \\text{ m})\\) , we can compute its orbital period \\((T)\\) . Computational Model The following Python script simulates a circular orbit and verifies Kepler\u2019s Third Law using numerical data. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) # Function to calculate orbital period def orbital_period(r, M): \"\"\"Calculate orbital period T given radius r and central mass M.\"\"\" return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Range of orbital radii (meters) r_values = np.linspace(5e9, 2e11, 100) # From 5 million to 200 million meters # Calculate periods for orbits around Sun and Earth (in days) T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Verify T^2 vs r^3 r3 = r_values**3 T2_sun = T_sun**2 T2_earth = T_earth**2 # Plot 1: T^2 vs r^3 to verify Kepler's Third Law plt.figure(figsize=(10, 6)) plt.plot(r3, T2_sun, label=\"Orbits around Sun\", color=\"orange\") plt.plot(r3, T2_earth, label=\"Orbits around Earth\", color=\"blue\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (days$^2$)\") plt.title(\"Verification of Kepler\u2019s Third Law: $T^2 \\\\propto r^3$\") plt.legend() plt.grid(True) plt.show() # Simulate circular orbits for specific examples def simulate_orbit(r, T, label, color): \"\"\"Simulate and plot a circular orbit.\"\"\" theta = np.linspace(0, 2 * np.pi, 100) # Angular positions t = np.linspace(0, T, 100) # Time steps over one period x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) plt.plot(x, y, label=label, color=color) plt.plot(0, 0, \"o\", color=\"black\", label=\"Central Body\") # Central mass # Example orbits r_earth_sun = 1.496e11 # Earth\u2019s orbit around Sun (m) T_earth_sun = orbital_period(r_earth_sun, M_sun) # Period in seconds r_moon_earth = 3.844e8 # Moon\u2019s orbit around Earth (m) T_moon_earth = orbital_period(r_moon_earth, M_earth) # Plot 2: Circular orbits visualization plt.figure(figsize=(8, 8)) simulate_orbit(r_earth_sun, T_earth_sun, \"Earth around Sun\", \"orange\") simulate_orbit(r_moon_earth, T_moon_earth, \"Moon around Earth\", \"gray\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show() # Print example values for verification print(f\"Earth\u2019s orbital radius: {r_earth_sun:.2e} m\") print(f\"Earth\u2019s orbital period: {T_earth_sun / (24 * 3600):.2f} days\") print(f\"Moon\u2019s orbital radius: {r_moon_earth:.2e} m\") print(f\"Moon\u2019s orbital period: {T_moon_earth / (24 * 3600):.2f} days\") Explanation of the Code and Results This section explains the Python code used to simulate circular orbits and verify Kepler\u2019s Third Law \\(( T^2 \\propto r^3 )\\) , along with the results and their verification. Explanation of the Code Constants \\(( G )\\) , \\(( M_{\\text{sun}} )\\) , and \\(( M_{\\text{earth}} )\\) are defined using standard values: \\(( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} )\\) (gravitational constant), \\(( M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg} )\\) (mass of the Sun), \\(( M_{\\text{earth}} = 5.972 \\times 10^{24} \\, \\text{kg} )\\) (mass of the Earth). Orbital Period Function The function orbital_period(r, M) implements: \\( \\(T = \\sqrt{\\frac{4\\pi^2 r^3}{G M}}\\) \\) This comes from Kepler\u2019s Third Law, rearranged from \\( \\(( T^2 = \\frac{4\\pi^2}{G M} r^3 )\\) \\) . Periods are converted from seconds to days (divided by \\(( 24 \\times 3600 )\\) ) for readability. Verification Plot Computes \\(r^3\\) and \\(T^2\\) for a range of radii \\(5 \\times 10^9\\) to \\(( 2 \\times 10^{11} \\, \\text{m} )\\) . Plots \\(T^2\\) vs. \\(r^3\\) for orbits around the Sun and Earth. A straight line is expected, as $T^2 \\propto r^3 $, with the slope given by \\(\\frac{4\\pi^2}{G M}\\) . Orbit Simulation The function simulate_orbit(r, T, label, color) calculates $ x $ and $ y $ coordinates for one orbit: $ x = r \\cos\\left(\\frac{2\\pi t}{T}\\right) $, $ y = r \\sin\\left(\\frac{2\\pi t}{T}\\right) $, where $ t $ is time over one period, and $ \\theta = \\frac{2\\pi t}{T} $ is the angular position. These parametric equations describe uniform circular motion. Plots Earth\u2019s orbit around the Sun and the Moon\u2019s orbit around Earth. Output Two Plots : One verifying $ T^2 \\propto r^3 $ (linearity check). One showing circular orbits (visual representation). Printed Values : Orbital radii and periods for Earth and Moon orbits, compared with real data. Results and Verification Plot 1: $ T^2 $ vs. $ r^3 $ Description : The plot shows a linear relationship between $ T^2 $ in days and $ r^3 $ (in \\(m^3\\) ), confirming: $$ T^2 \\propto r^3 $$ Slope : Depends on $ \\frac{4\\pi^2}{G M} $: Smaller slope for the Sun (larger $ M $) than for Earth, as $ M_{\\text{sun}} \\gg M_{\\text{earth}} $. Verification : Linearity matches Kepler\u2019s Third Law, with the constant of proportionality validated by the central mass. Plot 2: Circular Orbits Description : Visualizes: Earth\u2019s orbit around the Sun \\(( r = 1.496 \\times 10^{11} \\, \\text{m} )\\) , Moon\u2019s orbit around Earth \\(( r = 3.844 \\times 10^8 \\, \\text{m} )\\) . Scale Difference : The Moon\u2019s orbit appears small due to the vast difference in radii $ 10^{11} $ vs. $ 10^8 $. Verification : The circular shapes align with the assumption of circular motion, and calculated periods match real values: Earth: $ T \\approx 365.25 \\, \\text{days} $, Moon: $ T \\approx 27.32 \\, \\text{days} $. Conclusion The code accurately simulates circular orbits and verifies Kepler\u2019s Third Law. The linear $ T^2 $ vs. $ r^3 $ plot confirms the theoretical relationship, while the orbit visualization illustrates the physical motion. Printed values align with astronomical observations, reinforcing the model\u2019s validity. This Markdown document is formatted for clarity and compatibility with LaTeX rendering tools. Let me know if you\u2019d like further elaboration or additional details!","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law states that the square of the orbital period \\((T^2)\\) of a planet is proportional to the cube of its semi-major axis \\((r^3)\\) . This fundamental principle in celestial mechanics is derived from Newton\u2019s Law of Universal Gravitation and centripetal force equilibrium in circular orbits. This document will: - Derive the relationship between \\((T^2)\\) and \\((r^3)\\) . - Discuss its implications in astronomy. - Implement a computational model for circular orbits. - Visualize the relationship between \\((T^2)\\) and \\((r^3)\\) .","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"We start with Newton\u2019s Law of Universal Gravitation , which states that the gravitational force between two masses \\((m)\\) and \\((M)\\) is: \\[ F = \\frac{G M m}{r^2} \\] where: - \\((G)\\) is the gravitational constant \\((6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})\\) , - \\((M)\\) is the mass of the central body (e.g., the Sun for planetary orbits), - \\((m)\\) is the orbiting mass, - \\((r)\\) is the orbital radius. For a circular orbit, the centripetal force required to maintain the orbit is: \\[ F = m \\frac{v^2}{r} \\] where: - \\((v)\\) is the orbital velocity. Setting gravitational force equal to centripetal force: \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] Canceling \\((m)\\) from both sides: \\[ \\frac{G M}{r^2} = \\frac{v^2}{r} \\] Rearranging for velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\((T)\\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\((v)\\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} \\] Rewriting: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\]","title":"Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-third-law-in-astronomy","text":"The relationship \\[ T^2 \\propto r^3 \\] derived from Kepler\u2019s Third Law has profound implications in astronomy, particularly in determining planetary masses, calculating distances, and understanding celestial mechanics. Below are some key applications:","title":"Implications of Kepler\u2019s Third Law in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-determining-the-mass-of-celestial-bodies","text":"By rewriting Kepler\u2019s Third Law in terms of mass: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] we can calculate the mass of a central body (e.g., a planet or star) if we know the orbital period and orbital radius of a smaller orbiting object.","title":"1. Determining the Mass of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-finding-the-mass-of-the-sun","text":"Using Earth\u2019s orbit around the Sun: - $ r = 1.496 \\times 10^{11} \\, \\text{m} $ (1 AU), - $ T = 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s} $, - $ G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $. Plugging these values in: \\[ M_{\\odot} = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.674 \\times 10^{-11}) (3.156 \\times 10^7)^2} \\] \\[ M_{\\odot} \\approx 1.989 \\times 10^{30} \\, \\text{kg} \\] This matches the known mass of the Sun. Similarly, the mass of planets can be determined by observing their moons.","title":"Example: Finding the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-estimating-the-distance-to-planets-and-moons","text":"Since we know that: \\[ r^3 = \\frac{G M T^2}{4\\pi^2} \\] if we measure the orbital period of a satellite or planet, we can calculate its distance from the central body: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\]","title":"2. Estimating the Distance to Planets and Moons"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-measuring-the-distance-of-jupiters-moons","text":"Galileo\u2019s observations of Jupiter\u2019s moons led to estimates of their orbital radii. By measuring their orbital periods, astronomers calculated their distances from Jupiter. This method applies to exoplanets\u2014measuring the transit time of a planet around a distant star helps estimate its orbital radius.","title":"Example: Measuring the Distance of Jupiter\u2019s Moons"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-predicting-the-motion-of-satellites-and-spacecraft","text":"Kepler\u2019s Law governs how satellites orbit Earth. Space agencies use it to calculate fuel needs and plan satellite deployments. Geostationary satellites (e.g., GPS satellites) are placed in orbits where their period matches Earth\u2019s rotation ($ T = 24 \\, \\text{hours} $), ensuring they stay fixed above one location. Using $ T^2 \\propto r^3 $, we can determine the correct altitude needed for stable satellite orbits. For a geostationary orbit: \\[ r = \\left( \\frac{G M_{\\text{Earth}} (24 \\times 3600)^2}{4\\pi^2} \\right)^{1/3} \\approx 4.22 \\times 10^7 \\, \\text{m} \\] This corresponds to an altitude of about 35,786 km above Earth\u2019s equator.","title":"3. Predicting the Motion of Satellites and Spacecraft"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-exoplanet-discovery-and-characterization","text":"The radial velocity method and transit method both rely on Kepler\u2019s Third Law to determine exoplanet orbits. Transit Method : When a planet passes in front of a star, its orbital period $ T $ can be measured. Radial Velocity Method : By observing how a star wobbles due to gravitational interaction, astronomers infer a planet\u2019s mass and distance.","title":"4. Exoplanet Discovery and Characterization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-kepler-space-telescope-discoveries","text":"NASA\u2019s Kepler telescope discovered thousands of exoplanets by measuring orbital periods and applying Kepler\u2019s Law to estimate planetary distances from their stars: \\[ r = \\left( \\frac{G M_{\\text{star}} T^2}{4\\pi^2} \\right)^{1/3} \\]","title":"Example: Kepler Space Telescope Discoveries"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-binary-star-systems-and-black-hole-masses","text":"Kepler\u2019s Third Law extends to binary star systems, where two stars orbit a common center of mass. The total mass of the system is: \\[ M_1 + M_2 = \\frac{4\\pi^2 r^3}{G T^2} \\] By measuring the orbital period and separation distance, astronomers determine the combined mass of both stars. This is one of the main methods used to detect stellar-mass black holes by observing their interaction with a companion star.","title":"5. Binary Star Systems and Black Hole Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-cygnus-x-1-black-hole","text":"By applying Kepler\u2019s Law to the orbit of a star around an unseen object, astronomers confirmed the presence of a black hole with a mass of approximately $ 21 M_{\\odot} $.","title":"Example: Cygnus X-1 Black Hole"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-understanding-the-structure-of-the-solar-system-and-galaxies","text":"Orbital mechanics of planets, moons, and asteroids are explained using Kepler\u2019s Third Law. The orbital speeds of stars around galaxies deviate from predictions, providing evidence for dark matter.","title":"6. Understanding the Structure of the Solar System and Galaxies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-dark-matter-evidence","text":"Kepler\u2019s Law predicts that stars farther from a galaxy\u2019s center should orbit more slowly, with velocity scaling as: \\[ v \\propto \\frac{1}{\\sqrt{r}} \\] Observations show that they orbit faster than expected (a flat rotation curve), leading to the hypothesis of dark matter contributing additional mass: \\[ M_{\\text{total}} = \\frac{v^2 r}{G} \\] This discrepancy suggests unseen mass influencing gravitational dynamics. This Markdown document is now properly formatted with LaTeX for equations, clear section headings, and consistent notation. It\u2019s ready for use in platforms like GitHub, Jupyter Notebook, or other Markdown renderers. Let me know if you\u2019d like further adjustments!","title":"Example: Dark Matter Evidence"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-moons-orbit-around-earth","text":"The Moon\u2019s orbit around Earth follows Kepler\u2019s Third Law. Given: - Earth\u2019s mass \\((M = 5.972 \\times 10^{24} \\text{ kg})\\) , - Orbital radius of the Moon \\((r \\approx 3.844 \\times 10^8 \\text{ m})\\) , we can compute its orbital period \\((T)\\) .","title":"Real-World Example: Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"The following Python script simulates a circular orbit and verifies Kepler\u2019s Third Law using numerical data. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) # Function to calculate orbital period def orbital_period(r, M): \"\"\"Calculate orbital period T given radius r and central mass M.\"\"\" return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Range of orbital radii (meters) r_values = np.linspace(5e9, 2e11, 100) # From 5 million to 200 million meters # Calculate periods for orbits around Sun and Earth (in days) T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Verify T^2 vs r^3 r3 = r_values**3 T2_sun = T_sun**2 T2_earth = T_earth**2 # Plot 1: T^2 vs r^3 to verify Kepler's Third Law plt.figure(figsize=(10, 6)) plt.plot(r3, T2_sun, label=\"Orbits around Sun\", color=\"orange\") plt.plot(r3, T2_earth, label=\"Orbits around Earth\", color=\"blue\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (days$^2$)\") plt.title(\"Verification of Kepler\u2019s Third Law: $T^2 \\\\propto r^3$\") plt.legend() plt.grid(True) plt.show() # Simulate circular orbits for specific examples def simulate_orbit(r, T, label, color): \"\"\"Simulate and plot a circular orbit.\"\"\" theta = np.linspace(0, 2 * np.pi, 100) # Angular positions t = np.linspace(0, T, 100) # Time steps over one period x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) plt.plot(x, y, label=label, color=color) plt.plot(0, 0, \"o\", color=\"black\", label=\"Central Body\") # Central mass # Example orbits r_earth_sun = 1.496e11 # Earth\u2019s orbit around Sun (m) T_earth_sun = orbital_period(r_earth_sun, M_sun) # Period in seconds r_moon_earth = 3.844e8 # Moon\u2019s orbit around Earth (m) T_moon_earth = orbital_period(r_moon_earth, M_earth) # Plot 2: Circular orbits visualization plt.figure(figsize=(8, 8)) simulate_orbit(r_earth_sun, T_earth_sun, \"Earth around Sun\", \"orange\") simulate_orbit(r_moon_earth, T_moon_earth, \"Moon around Earth\", \"gray\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show() # Print example values for verification print(f\"Earth\u2019s orbital radius: {r_earth_sun:.2e} m\") print(f\"Earth\u2019s orbital period: {T_earth_sun / (24 * 3600):.2f} days\") print(f\"Moon\u2019s orbital radius: {r_moon_earth:.2e} m\") print(f\"Moon\u2019s orbital period: {T_moon_earth / (24 * 3600):.2f} days\")","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation-of-the-code-and-results","text":"This section explains the Python code used to simulate circular orbits and verify Kepler\u2019s Third Law \\(( T^2 \\propto r^3 )\\) , along with the results and their verification.","title":"Explanation of the Code and Results"},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation-of-the-code","text":"","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"\\(( G )\\) , \\(( M_{\\text{sun}} )\\) , and \\(( M_{\\text{earth}} )\\) are defined using standard values: \\(( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} )\\) (gravitational constant), \\(( M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg} )\\) (mass of the Sun), \\(( M_{\\text{earth}} = 5.972 \\times 10^{24} \\, \\text{kg} )\\) (mass of the Earth).","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-function","text":"The function orbital_period(r, M) implements: \\( \\(T = \\sqrt{\\frac{4\\pi^2 r^3}{G M}}\\) \\) This comes from Kepler\u2019s Third Law, rearranged from \\( \\(( T^2 = \\frac{4\\pi^2}{G M} r^3 )\\) \\) . Periods are converted from seconds to days (divided by \\(( 24 \\times 3600 )\\) ) for readability.","title":"Orbital Period Function"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verification-plot","text":"Computes \\(r^3\\) and \\(T^2\\) for a range of radii \\(5 \\times 10^9\\) to \\(( 2 \\times 10^{11} \\, \\text{m} )\\) . Plots \\(T^2\\) vs. \\(r^3\\) for orbits around the Sun and Earth. A straight line is expected, as $T^2 \\propto r^3 $, with the slope given by \\(\\frac{4\\pi^2}{G M}\\) .","title":"Verification Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbit-simulation","text":"The function simulate_orbit(r, T, label, color) calculates $ x $ and $ y $ coordinates for one orbit: $ x = r \\cos\\left(\\frac{2\\pi t}{T}\\right) $, $ y = r \\sin\\left(\\frac{2\\pi t}{T}\\right) $, where $ t $ is time over one period, and $ \\theta = \\frac{2\\pi t}{T} $ is the angular position. These parametric equations describe uniform circular motion. Plots Earth\u2019s orbit around the Sun and the Moon\u2019s orbit around Earth.","title":"Orbit Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output","text":"Two Plots : One verifying $ T^2 \\propto r^3 $ (linearity check). One showing circular orbits (visual representation). Printed Values : Orbital radii and periods for Earth and Moon orbits, compared with real data.","title":"Output"},{"location":"1%20Physics/2%20Gravity/Problem_1/#results-and-verification","text":"","title":"Results and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-1-t2-vs-r3","text":"Description : The plot shows a linear relationship between $ T^2 $ in days and $ r^3 $ (in \\(m^3\\) ), confirming: $$ T^2 \\propto r^3 $$ Slope : Depends on $ \\frac{4\\pi^2}{G M} $: Smaller slope for the Sun (larger $ M $) than for Earth, as $ M_{\\text{sun}} \\gg M_{\\text{earth}} $. Verification : Linearity matches Kepler\u2019s Third Law, with the constant of proportionality validated by the central mass.","title":"Plot 1: $ T^2 $ vs. $ r^3 $"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-2-circular-orbits","text":"Description : Visualizes: Earth\u2019s orbit around the Sun \\(( r = 1.496 \\times 10^{11} \\, \\text{m} )\\) , Moon\u2019s orbit around Earth \\(( r = 3.844 \\times 10^8 \\, \\text{m} )\\) . Scale Difference : The Moon\u2019s orbit appears small due to the vast difference in radii $ 10^{11} $ vs. $ 10^8 $. Verification : The circular shapes align with the assumption of circular motion, and calculated periods match real values: Earth: $ T \\approx 365.25 \\, \\text{days} $, Moon: $ T \\approx 27.32 \\, \\text{days} $.","title":"Plot 2: Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"The code accurately simulates circular orbits and verifies Kepler\u2019s Third Law. The linear $ T^2 $ vs. $ r^3 $ plot confirms the theoretical relationship, while the orbit visualization illustrates the physical motion. Printed values align with astronomical observations, reinforcing the model\u2019s validity. This Markdown document is formatted for clarity and compatibility with LaTeX rendering tools. Let me know if you\u2019d like further elaboration or additional details!","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}